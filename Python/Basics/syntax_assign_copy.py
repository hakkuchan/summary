""" · 目录
    |
    |—— 1. 赋值
    |
    |—— 2. 浅拷贝
    |
    |—— 3. 深拷贝
"""



""" 1. 赋值
    · 在Python中进行赋值 (例如 m = 5) 时，计算机做了两件事：
      先是在某个内存位置存放了数据对象 5；然后在某个内存位置存放了变量名 m，并把它指向 5 的内存位置
    · 当写 n = m 时，相当于用变量名 n 指向 m 所指的内存位置；
      也就是说，变量名 m 和 n 指向的内存位置相同，操作 m 就等价于操作 n
      但对m重新赋值不等于对n重新赋值
"""

# 例 1：
m = 5
n = m
print(id(m) == id(n)) # >>> True  说明 m 和 n 指向的内存位置相同

# 例 2：
m = 5
n = m
m = 6  # 对 m 重新赋值
print(id(m) == id(n)) # >>> Flase 说明对 m 重新赋值导致 m 和 n 指向不同的内存位置

# 例 3：
m = 5
n = m
m = 5  # 对 m 重新赋值，其值与 n 相同
print(id(m) == id(n)) # >>> True 说明 m 与 n 又指向了同一内存位置

# 例 4：
m = [1, 2, ['a', 'b']]
n = m
m.append(True)   # 对 m 操作，等价于对 n 操作
print(m)  # >>> [1, 2, ['a', 'b'], True]
print(n)  # >>> [1, 2, ['a', 'b'], True]

# 例 5：
m = [1, 2]
n = 2 * [m]  # n 的运算指向 m 所指的内存位置
print(n)     # >>> [[1, 2], [1, 2]]
m.append(3)  # 对 m 进行操作，n 也会相应变化 
print(n)     # >>> [[1, 2, 3], [1, 2, 3]]
print(id(m) == id(n))  # >>> False  说明 m 和 n 指向的内存位置不同



""" 2. 浅拷贝 
        
    · m = [1, 2, ['a', 'b']]，
      相当于在某个内存位置存放数据对象 [1, 2, ['a', 'b']]，并用变量名 m 指向这个位置
      其中的元素 1、2、['a', 'b'] 也各自占据一个内存位置，依次被变量名 m[0], m[1], m[2] 所指向

    · 浅拷贝：n = m.copy()，相当于产生1个新内存位置，并用变量名 n 指向这个位置
      但 n 位置所拷贝的是 m[0], m[1], m[2] 指向的内存位置

    · 简言之，m 和 n 指向的内存位置不同，但 m[0], m[1], m[2] 和 n[0], n[1], n[2] 指向的内存位置相同
"""

# 例：
m = [1, 2, ['a', 'b']]
n = m.copy()
print(id(m) == id(n))        # >>> False  说明 m 和 n 指向的内存位置不同
print(id(m[2]) == id(n[2]))  # >>> True   说明 m[2] 和 n[2] 指向的内存位置相同

m.append(True)   # m 和 n 指向的内存位置不同，操作 m 不影响 n
print(m)  # >>> [1, 2, ['a', 'b'], True]
print(n)  # >>> [1, 2, ['a', 'b']]

n[2].append('c') # n[2] 和 m[2] 指向的内存位置相同，操作 n[2] 等价于操作 m[2] 
print(m)  # >>> [1, 2, ['a', 'b', 'c'], True]
print(n)  # >>> [1, 2, ['a', 'b', 'c']]



""" 3. 深拷贝（需引入模块 copy）
        
    · m = 5，相当于在内存某个位置存放了数据对象 5，并用变量名 m 指向这个位置

    · 深拷贝：n = copy.deepcopy(m)，
      相当于产生 1 个新内存位置，拷贝数据对象 5 到这个新位置，并用 n 指向新位置

    · 换言之，m 和 n 指向两个内存位置，m 和 n 完全独立
"""

# 例：
import copy
m = [1, 2, ['a', 'b']]
n = copy.deepcopy(m)
print(id(m) == id(n))        # >>> False  说明 m 和 n 指向的内存位置不同
print(id(m[2]) == id(n[2]))  # >>> False  说明 m[2] 和 n[2] 指向的内存位置不同

m.append(100)    # 对 m 操作，对 n 没有影响 
n[2].append('c') # 对 n[2] 操作，对 m[2] 没有影响
print(m)  # >>> [1, 2, ['a', 'b'], 100]
print(n)  # >>> [1, 2, ['a', 'b', 'c']]
