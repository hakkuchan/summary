1. 模块（module)：
   一个包含Python代码的.py文件（包含了函数、特殊值等），比如math模块
   import math >>> type(math) >>> module
   查看module中定义的所有功能：dir(modulename)，比如 dir(math)
	
    （1） 导入module的方法，以math为例：
        
        直接导入：
        import math
        import math as m
        
        导入模块中的某个函数或值
        from math import pi, log 或 from math import log as ln
		
        只能一句一句import，不能像这样：from math import log, log10 as ln, lg
        也不能像这样导入： import math.log as ln （import A.B 的语法不适用于module，只适用于package）

        导入模块内定义的所有内容
        from math import *
        不要使用这个功能，因为它在解释器中引入了一组module内的名称，它们很可能会覆盖一些你已经定义过的东西

    （2）导入自定义module（比如 my_module.py）
		
		方法1：查看现有包（如pandas）所在路径，将my_module.py存入该路径
		import pandas
        print(pandas.__file__)
		
        方法2：假如 my_module.py 的保存路径为 E:/Work，先添加其位置：
        import sys
        sys.path.append('E:/Work/')

        之后便可 import my_module
	
	（3）模块的选择型运行 (if __name__ == '__main__': 的作用)

        Python 是解释型语言，从脚本第一行开始运行。
        从顶层导入一个模块（本质上，一个 .py 文件）时，程序会从顶层模块代码直接运行。
        比如，有一个模块 hello_world.py，其内容为：print('Hello world !')

        import hello_world
        会直接输出：Hello world ！
 
        显然，我们只希望引入 hello_world 模块，不希望运行其中的代码
        因此，把 hello_world.py 改写为：

        if __name__ == '__main__':
            print('Hello world !')

        此时就只引入模块，而不运行模块中 if __name__ == '__main__': 后面的代码

        理解如下：__name__ 是当前文件的内置变量，存储着当前模块（.py 文件）的名字
		
		当模块被运行时，当前模块名是 __main__，因此 __name__=='__main__' is True，于是执行之后的代码，

        当模块（比如 hello_world.py）被引入时，模块名是 hello_world. 因此 __name__=='__main__' is False，便不执行之后的代码。

        综上，if __name__ == '__main__': 的作用判断当前模块是在被运行还是被引入，进而选择性执行之后的代码


2. 包（package）：
    package是一个包含了多个module或子包(内含module和子包)的文件夹，比如sklearn
    
    （1）导入方式
        直接导入 import sklearn
        导入内部模块或子包 import sklearn.preprocessing (可以连续，如A.B.C)
        也可以 import sklearn.preprocessing as preproecss
        也可以 from sklearn import preprocessing as preprocess
        from sklearn import * 不推荐，耗时且可能有副作用
    
    （2）package中必然包含__init__.py 文件
        其作用是将普通文件夹变为一个package，在导入一个包时，实际上是导入了它的__init__.py文件,
        这样我们可以在__init__.py文件中批量导入我们所需要的模块，而不再需要一个一个的导入
        
        __init__.py 一般是一个空文件，也可定义一个列表 __all__
        若定义了列表 __all__，from package import * 时，就会导入package的所有列表名（显式）。如果没有这个定义，就只导入package。
            举例：
                from sklearn import *
                如果sklearn中的__init__.py文件含有__all__列表，那么就可以直接用其中的module，比如preprocessing。
                    a = preprocessing.MinMaxScaler......
                反之，如果sklearn中的__init__.py文件没有__all__列表（实际上有），那么 from sklearn import * 后，依然不能直接使用其中的module